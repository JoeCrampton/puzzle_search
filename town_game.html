<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Town Explorer</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background-color: #2c3e50;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #gameCanvas {
            border: 3px solid #34495e;
            background-color: #ecf0f1;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            outline: none;
        }
        
        h1 {
            color: #ecf0f1;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .instructions {
            color: #bdc3c7;
            text-align: center;
            margin-top: 10px;
            font-size: 14px;
            max-width: 600px;
        }
    </style>
</head>
<body>
    <h1>üèòÔ∏è Town Explorer</h1>
    <canvas id="gameCanvas" width="1000" height="600" tabindex="0"></canvas>
    <div class="instructions">
        <p>Use arrow keys to move ‚Ä¢ Walk on roads and driveways ‚Ä¢ Enter buildings through doors ‚Ä¢ Press SPACE to exit buildings</p>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        const SCREEN_WIDTH = 1000;
        const SCREEN_HEIGHT = 600;
        const SIDEBAR_WIDTH = SCREEN_WIDTH * 0.25; // 25% for left sidebar
        const GAME_WIDTH = SCREEN_WIDTH * 0.75; // 75% for game area
        const GAME_OFFSET_X = SIDEBAR_WIDTH; // Game starts after sidebar
        
        // Grid system: 14 columns √ó 9 rows (now within the 75% game area)
        const GRID_COLS = 14;
        const GRID_ROWS = 9;
        const CELL_WIDTH = GAME_WIDTH / GRID_COLS;  // ~53px per cell in game area
        const CELL_HEIGHT = SCREEN_HEIGHT / GRID_ROWS; // ~78px per cell
        
        const DRIVEWAY_WIDTH = 40;
        const DRIVEWAY_HEIGHT = 17;
        const DOOR_SIZE = 20;
        
        // Colors
        const COLORS = {
            GRASS: '#4CAF50',
            ROAD: '#616161',
            DRIVEWAY: '#757575',
            PLAYER: '#2196F3',
            DOOR: '#8D6E63',
            WHITE: '#FFFFFF',
            BLACK: '#000000',
            
            // Building colors
            FIRE_STATION: '#F44336',
            POLICE: '#3F51B5',
            HOSPITAL: '#FF9800',
            SCHOOL: '#9C27B0',
            LIBRARY: '#607D8B',
            RESTAURANT: '#E91E63',
            BANK: '#795548',
            MUSEUM: '#009688',
            POST_OFFICE: '#FF5722',
            GROCERY: '#8BC34A',
            GAS_STATION: '#FFC107',
            PARK_OFFICE: '#4CAF50'
        };
        
        // Convert grid coordinates (1,1 = bottom left) to screen coordinates within game area
        function gridToScreen(gridX, gridY) {
            return {
                x: GAME_OFFSET_X + (gridX - 1) * CELL_WIDTH,
                y: SCREEN_HEIGHT - (gridY * CELL_HEIGHT)
            };
        }
        
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = 14;
                this.speed = 3;
            }
            
            move(dx, dy, game) {
                const newX = this.x + dx * this.speed;
                const newY = this.y + dy * this.speed;
                
                if (game.canMoveTo(newX, this.y, this.size)) {
                    this.x = newX;
                }
                if (game.canMoveTo(this.x, newY, this.size)) {
                    this.y = newY;
                }
            }
            
            draw() {
                // Player as a blue circle with simple face
                ctx.fillStyle = COLORS.PLAYER;
                ctx.beginPath();
                ctx.arc(this.x + this.size/2, this.y + this.size/2, this.size/2, 0, Math.PI * 2);
                ctx.fill();
                
                // Eyes
                ctx.fillStyle = COLORS.WHITE;
                ctx.beginPath();
                ctx.arc(this.x + this.size/2 - 3, this.y + this.size/2 - 2, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(this.x + this.size/2 + 3, this.y + this.size/2 - 2, 2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            getBounds() {
                return {
                    x: this.x,
                    y: this.y,
                    width: this.size,
                    height: this.size
                };
            }
        }
        
        class Building {
            constructor(gridX, gridY, gridWidth, gridHeight, color, name, type) {
                this.gridX = gridX;
                this.gridY = gridY;
                this.gridWidth = gridWidth;
                this.gridHeight = gridHeight;
                this.color = color;
                this.name = name;
                this.type = type;
                
                // Convert grid coordinates to screen coordinates
                const screenPos = gridToScreen(gridX, gridY);
                this.x = screenPos.x + 5; // 5px margin within cell
                this.y = screenPos.y + 5;
                this.width = gridWidth * CELL_WIDTH - 10; // 10px total margin
                this.height = gridHeight * CELL_HEIGHT - 10;
                
                // Door position (bottom center of building)
                this.doorX = this.x + (this.width - DOOR_SIZE) / 2;
                this.doorY = this.y + this.height;
                
                // Calculate driveway to nearest road
                this.calculateDriveway();
            }
            
            calculateDriveway() {
                // Determine which road to connect to based on building position
                let roadRow;
                if (this.gridY >= 8) {
                    // Top buildings (rows 8-9) connect to road on row 7
                    roadRow = 7;
                } else if (this.gridY >= 5) {
                    // Middle buildings (rows 5-6) connect to road on row 4
                    roadRow = 4;
                } else {
                    // Bottom buildings (rows 2-3) connect to road on row 1
                    roadRow = 1;
                }
                
                // Calculate the actual road position with the centered narrow roads
                const roadScreenPos = gridToScreen(1, roadRow);
                const roadHeight = CELL_HEIGHT * 0.75;
                const roadVerticalOffset = CELL_HEIGHT * 0.125;
                const roadY = roadScreenPos.y + roadVerticalOffset;
                
                // Driveway positioning
                this.drivewayX = this.doorX + (DOOR_SIZE - DRIVEWAY_WIDTH) / 2;
                this.drivewayWidth = DRIVEWAY_WIDTH;
                
                // Calculate driveway to just touch road edge (not overlap)
               
                    // All buildings: driveway goes down from door to top edge of road
                    this.drivewayY = this.doorY + 1;
                    this.drivewayHeight = roadY - this.drivewayY;

            }
            
            
            getBuildingIcon() {
                // Return appropriate emoji icon based on building type
                switch(this.type) {
                    case 'fire': return 'üöí';
                    case 'police': return 'üëÆ';
                    case 'hospital': return 'üè•';
                    case 'school': return 'üè´';
                    case 'library': return 'üìö';
                    case 'restaurant': return 'üçΩÔ∏è';
                    case 'bank': return 'üè¶';
                    case 'museum': return 'üèõÔ∏è';
                    case 'post': return 'üìÆ';
                    case 'grocery': return 'üõí';
                    case 'gas': return '‚õΩ';
                    case 'park': return 'üå≥';
                    case 'clinic': return '‚öïÔ∏è';
                    default: return 'üè¢';
                }
            }
            
            draw() {
                // Simple background rectangle
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.strokeStyle = COLORS.BLACK;
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, this.y, this.width, this.height);
                
                // Building icon (large emoji in center)
                const icon = this.getBuildingIcon();
                ctx.font = '48px Arial';
                ctx.textAlign = 'center';
                const iconX = this.x + this.width / 2;
                const iconY = this.y + this.height / 2 + 15; // Offset for text baseline
                ctx.fillText(icon, iconX, iconY);
                
                // Building label
                ctx.fillStyle = COLORS.WHITE;
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                const textX = this.x + this.width / 2;
                const textY = this.y + this.height - 8;
                
                // Text background for readability
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                const textWidth = ctx.measureText(this.name).width;
                ctx.fillRect(textX - textWidth/2 - 4, textY - 12, textWidth + 8, 16);
                
                ctx.fillStyle = COLORS.WHITE;
                ctx.fillText(this.name, textX, textY);
                
                // Door
                ctx.fillStyle = COLORS.DOOR;
                ctx.fillRect(this.doorX, this.doorY, DOOR_SIZE, 8);
                ctx.strokeStyle = COLORS.BLACK;
                ctx.lineWidth = 1;
                ctx.strokeRect(this.doorX, this.doorY, DOOR_SIZE, 8);
                
                // Door handle
                ctx.fillStyle = COLORS.WHITE;
                ctx.beginPath();
                ctx.arc(this.doorX + DOOR_SIZE - 3, this.doorY + 4, 1.5, 0, Math.PI * 2);
                ctx.fill();
                
                // Driveway
                ctx.fillStyle = COLORS.DRIVEWAY;
                ctx.fillRect(this.drivewayX, this.drivewayY, this.drivewayWidth, this.drivewayHeight);
            }
            
            checkDoorCollision(player) {
                const playerBounds = player.getBounds();
                return playerBounds.x < this.doorX + DOOR_SIZE &&
                       playerBounds.x + playerBounds.width > this.doorX &&
                       playerBounds.y < this.doorY + 8 &&
                       playerBounds.y + playerBounds.height > this.doorY;
            }
            
            drawInterior(game) {
                // Clear screen with interior color
                ctx.fillStyle = '#F5F5F5';
                ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
                
                // Building outline (walls)
                ctx.strokeStyle = COLORS.BLACK;
                ctx.lineWidth = 8;
                ctx.strokeRect(50, 50, SCREEN_WIDTH - 100, SCREEN_HEIGHT - 100);
                
                // Building icon (left of title)
                const icon = this.getBuildingIcon();
                ctx.font = '48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(icon, SCREEN_WIDTH / 2 - 100, 130);
                
                // Building name (to the right of icon)
                ctx.fillStyle = COLORS.BLACK;
                ctx.font = '36px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(this.name, SCREEN_WIDTH / 2 - 50, 120);
                
                // Draw puzzle piece if this building has one and it's not collected
                if (game.buildingsWithPieces.has(this.name) && !game.collectedFromBuildings.has(this.name)) {
                    this.drawMathProblem(game);
                }
                
                // Exit door at bottom
                ctx.fillStyle = COLORS.DOOR;
                ctx.fillRect((SCREEN_WIDTH - 30) / 2, SCREEN_HEIGHT - 58, 30, 8);
                ctx.strokeStyle = COLORS.BLACK;
                ctx.lineWidth = 2;
                ctx.strokeRect((SCREEN_WIDTH - 30) / 2, SCREEN_HEIGHT - 58, 30, 8);
                
                // Instructions
                ctx.fillStyle = '#666';
                ctx.font = '18px Arial';
                ctx.textAlign = 'center';
                if (game.collectedFromBuildings.has(this.name)) {
                    ctx.fillText('Puzzle piece collected! ‚Ä¢ Walk to door or press SPACE to exit', SCREEN_WIDTH / 2, SCREEN_HEIGHT - 20);
                } else if (game.buildingsWithPieces.has(this.name)) {
                    if (game.currentMathAnswer !== null) {
                        ctx.fillText('Type your answer and press ENTER ‚Ä¢ Press SPACE to exit', SCREEN_WIDTH / 2, SCREEN_HEIGHT - 20);
                    } else {
                        ctx.fillText('Solve the math problem to get the puzzle piece ‚Ä¢ Press SPACE to exit', SCREEN_WIDTH / 2, SCREEN_HEIGHT - 20);
                    }
                } else {
                    ctx.fillText('No puzzle piece here ‚Ä¢ Walk to door or press SPACE to exit', SCREEN_WIDTH / 2, SCREEN_HEIGHT - 20);
                }
            }
            
            drawMathProblem(game) {
                const problemX = SCREEN_WIDTH / 2;
                const problemY = SCREEN_HEIGHT / 2 + 100; // Move down 100px
                
                // Get the math problem for this building
                const problem = game.mathProblems[this.name];
                const pieceNumber = game.buildingToPiece[this.name];
                
                // Draw puzzle piece prize above the problem
                const pieceY = problemY - 180;
                const pieceSize = 60;
                
                if (game.imageLoaded) {
                    // Calculate source coordinates for this piece (2x4 grid)
                    const col = pieceNumber % 4;
                    const row = Math.floor(pieceNumber / 4);
                    
                    const sourceWidth = game.puzzleImage.width / 4;
                    const sourceHeight = game.puzzleImage.height / 2;
                    const sourceX = col * sourceWidth;
                    const sourceY = row * sourceHeight;
                    
                    // Draw the image piece
                    ctx.drawImage(
                        game.puzzleImage,
                        sourceX, sourceY, sourceWidth, sourceHeight,
                        problemX - pieceSize/2, pieceY - pieceSize/2, pieceSize, pieceSize
                    );
                    
                    // Add puzzle piece border
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(problemX - pieceSize/2, pieceY - pieceSize/2, pieceSize, pieceSize);
                }
                
                // Prize label
                ctx.fillStyle = COLORS.BLACK;
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`Puzzle Piece #${pieceNumber + 1}`, problemX, pieceY + pieceSize/2 + 20);
                
                // Problem background
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.fillRect(problemX - 250, problemY - 100, 500, 140);
                ctx.strokeStyle = COLORS.BLACK;
                ctx.lineWidth = 3;
                ctx.strokeRect(problemX - 250, problemY - 100, 500, 140);
                
                // Math problem text
                ctx.fillStyle = COLORS.BLACK;
                ctx.font = '18px Arial';
                ctx.textAlign = 'center';
                
                // Word wrap the question
                const words = problem.question.split(' ');
                let line = '';
                let y = problemY - 60;
                
                for (let i = 0; i < words.length; i++) {
                    const testLine = line + words[i] + ' ';
                    const metrics = ctx.measureText(testLine);
                    if (metrics.width > 460 && i > 0) {
                        ctx.fillText(line, problemX, y);
                        line = words[i] + ' ';
                        y += 25;
                    } else {
                        line = testLine;
                    }
                }
                ctx.fillText(line, problemX, y);
                
                // Answer input box
                const inputX = problemX - 60;
                const inputY = problemY + 10;
                const inputWidth = 120;
                const inputHeight = 30;
                
                ctx.fillStyle = COLORS.WHITE;
                ctx.fillRect(inputX, inputY, inputWidth, inputHeight);
                ctx.strokeStyle = '#2196F3';
                ctx.lineWidth = 2;
                ctx.strokeRect(inputX, inputY, inputWidth, inputHeight);
                
                // Answer label
                ctx.fillStyle = COLORS.BLACK;
                ctx.font = 'bold 16px Arial';
                ctx.fillText('Answer:', problemX - 100, inputY + 20);
                
                // Display current answer
                ctx.font = 'bold 18px Arial';
                ctx.fillStyle = COLORS.BLACK;
                const displayAnswer = game.currentMathAnswer !== null ? game.currentMathAnswer.toString() : '';
                ctx.fillText(displayAnswer, problemX, inputY + 20);
                
                // Feedback for wrong answers
                if (game.mathFeedback) {
                    ctx.fillStyle = game.mathFeedback.includes('Correct') ? '#4CAF50' : '#F44336';
                    ctx.font = 'bold 16px Arial';
                    ctx.fillText(game.mathFeedback, problemX, problemY + 70);
                }
            }
            
            checkPuzzlePieceCollection(player, game) {
                // This is now handled by math problem solving
                return false;
            }
            
            checkInteriorExit(player) {
                const playerBounds = player.getBounds();
                const exitDoorX = (SCREEN_WIDTH - 30) / 2;
                const exitDoorY = SCREEN_HEIGHT - 58;
                
                // Check if player is touching the exit door
                return playerBounds.x < exitDoorX + 100 &&
                       playerBounds.x + playerBounds.width > exitDoorX &&
                       playerBounds.y < exitDoorY + 100 &&
                       playerBounds.y + playerBounds.height > exitDoorY;
            }
        }
        
        class Game {
            constructor() {
                // Start player on road (row 4)
                const startPos = gridToScreen(7, 4);
                this.player = new Player(startPos.x + 30, startPos.y + 30);
                this.currentScreen = 'town';
                this.currentBuilding = null;
                this.keys = {};
                this.buildings = this.createBuildings();
                
                // Puzzle system
                this.totalPuzzlePieces = 8; // 8 pieces of unicorn puzzle
                this.collectedPieces = 0;
                this.collectedFromBuildings = new Set(); // Track which buildings we've collected from
                
                // Randomly choose between unicorn and cat
                this.puzzleType = Math.random() < 0.5 ? 'unicorn' : 'cat';
                this.puzzleImage = new Image();
                
                if (this.puzzleType === 'unicorn') {
                    this.puzzleImage.src = 'vecteezy_unicorn-strolling-on-the-beach-cartoon-clipart_6823393.jpg';
                    this.puzzleName = 'Unicorn';
                    this.puzzleEmoji = 'ü¶Ñ';
                } else {
                    this.puzzleImage.src = 'vecteezy_cartoon-cute-cat-isolated-on-white-background_.jpg';
                    this.puzzleName = 'Cat';
                    this.puzzleEmoji = 'üê±';
                }
                
                this.imageLoaded = false;
                
                this.puzzleImage.onload = () => {
                    this.imageLoaded = true;
                    console.log(`${this.puzzleName} image loaded successfully`);
                };
                
                this.puzzleImage.onerror = () => {
                    console.error(`Failed to load ${this.puzzleName} image`);
                    this.imageLoaded = false;
                };
                
                // Randomly assign 8 puzzle pieces to buildings
                this.assignPuzzlePieces();
                
                // Generate random math problems for each building
                this.generateMathProblems();
                
                // Math problem state
                this.currentMathAnswer = null;
                this.mathFeedback = '';
                
                // Celebration animation state
                this.showCelebration = false;
                this.celebrationStartTime = 0;
                this.celebrationPieceNumber = 0;
                
                // Audio context for sound effects
                this.audioContext = null;
                this.puzzleCompletedMusicPlayed = false; // Flag to prevent repeated music
                this.initAudio();
                
                this.setupEventListeners();
            }
            
            createBuildings() {
                return [
                    // Bottom row buildings (rows 2-3)
                    new Building(1.5, 3, 2, 2, COLORS.FIRE_STATION, 'Fire Station', 'fire'),
                    new Building(5.5, 3, 2, 2, COLORS.POLICE, 'Police Station', 'police'),
                    new Building(9, 3, 2, 2, COLORS.GROCERY, 'Grocery Store', 'grocery'),
                    new Building(12.5, 3, 2, 2, COLORS.BANK, 'Bank', 'bank'),
                    
                    // Middle row buildings (rows 5-6)
                    new Building(1.5, 6, 2, 2, COLORS.RESTAURANT, 'Restaurant', 'restaurant'),
                    new Building(5, 6, 3, 2, COLORS.MUSEUM, 'Museum', 'museum'), // 3x2 building
                    new Building(9, 6, 2, 2, COLORS.POST_OFFICE, 'Post Office', 'post'),
                    new Building(12.5, 6, 2, 2, COLORS.LIBRARY, 'Library', 'library'),
                    
                    // Top row buildings (rows 8-9)
                    new Building(1.5, 9, 2, 2, COLORS.HOSPITAL, 'Hospital', 'hospital'),
                    new Building(5, 9, 3, 2, COLORS.GAS_STATION, 'Gas Station', 'gas'), // 3x2 building
                    new Building(9, 9, 2, 2, COLORS.SCHOOL, 'School', 'school'),
                    new Building(12.5, 9, 2, 2, COLORS.PARK_OFFICE, 'Park Office', 'park')
                ];
            }
            
            assignPuzzlePieces() {
                // Create array of all building names
                const allBuildings = this.buildings.map(b => b.name);
                
                // Shuffle array and take first 8 buildings
                const shuffled = allBuildings.sort(() => Math.random() - 0.5);
                this.buildingsWithPieces = new Set(shuffled.slice(0, 8));
                
                // Map each selected building to a puzzle piece number
                this.buildingToPiece = {};
                shuffled.slice(0, 8).forEach((buildingName, index) => {
                    this.buildingToPiece[buildingName] = index;
                });
                
                // Generate new math problems
                this.generateMathProblems();
            }
            
            generateMathProblems() {
                // Template for each building type with thematic context
                const problemTemplates = {
                    'Fire Station': {
                        addition: (a, b) => `The fire station has ${a} firefighters on duty and ${b} more arrive for backup. How many firefighters are there in total?`,
                        subtraction: (a, b) => `The fire truck carries ${a} hoses. If firefighters use ${b} hoses to fight a fire, how many hoses are left?`
                    },
                    'Police Station': {
                        addition: (a, b) => `Officer Johnson patrols ${a} blocks in the morning and ${b} blocks in the afternoon. How many blocks did he patrol in total?`,
                        subtraction: (a, b) => `The police station has ${a} patrol cars. If ${b} cars are out on patrol, how many cars are at the station?`
                    },
                    'Hospital': {
                        addition: (a, b) => `Dr. Smith sees ${a} patients on Monday and ${b} patients on Tuesday. How many patients did she see in total?`,
                        subtraction: (a, b) => `The hospital has ${a} beds. If ${b} beds are occupied, how many beds are available?`
                    },
                    'School': {
                        addition: (a, b) => `The school has ${a} students in grade 3 and ${b} students in grade 4. How many students are there in both grades?`,
                        subtraction: (a, b) => `There are ${a} students in Ms. Garcia's class. If ${b} students are absent today, how many students are present?`
                    },
                    'Library': {
                        addition: (a, b) => `The library receives ${a} new books on Monday and ${b} more books on Tuesday. How many new books did they receive in total?`,
                        subtraction: (a, b) => `The library has ${a} books to shelve. If librarians shelve ${b} books, how many books are left to shelve?`
                    },
                    'Restaurant': {
                        addition: (a, b) => `Chef Carlos makes ${a} sandwiches for lunch and ${b} sandwiches for dinner. How many sandwiches did he make in total?`,
                        subtraction: (a, b) => `The restaurant prepares ${a} meals for the day. If customers order ${b} meals, how many meals are left?`
                    },
                    'Bank': {
                        addition: (a, b) => `Emma saves $${a} in January and $${b} in February. How much money did she save in total?`,
                        subtraction: (a, b) => `Tom has $${a} in his account. If he withdraws $${b}, how much money is left in his account?`
                    },
                    'Museum': {
                        addition: (a, b) => `The museum adds ${a} new artifacts on Monday and ${b} more on Wednesday. How many new artifacts were added in total?`,
                        subtraction: (a, b) => `The museum displays ${a} paintings. If ${b} paintings are moved to storage, how many paintings are still on display?`
                    },
                    'Post Office': {
                        addition: (a, b) => `The mail carrier delivers ${a} packages in the morning and ${b} packages in the afternoon. How many packages were delivered in total?`,
                        subtraction: (a, b) => `The post office has ${a} letters to deliver. If the mail carrier delivers ${b} letters, how many letters are left?`
                    },
                    'Grocery Store': {
                        addition: (a, b) => `The store receives ${a} boxes of cereal on Monday and ${b} boxes on Thursday. How many boxes did they receive in total?`,
                        subtraction: (a, b) => `The store has ${a} oranges. If customers buy ${b} oranges, how many oranges are left?`
                    },
                    'Gas Station': {
                        addition: (a, b) => `The gas station sells ${a} gallons of gas in the morning and ${b} gallons in the evening. How many gallons were sold in total?`,
                        subtraction: (a, b) => `The gas station has ${a} gallons of gas. If they sell ${b} gallons, how many gallons are left?`
                    },
                    'Park Office': {
                        addition: (a, b) => `The park plants ${a} trees on Monday and ${b} trees on Friday. How many trees were planted in total?`,
                        subtraction: (a, b) => `The park has ${a} picnic tables. If ${b} tables are being repaired, how many tables are available for visitors?`
                    }
                };
                
                this.mathProblems = {};
                
                // Generate random problems for each building
                for (const buildingName of Object.keys(problemTemplates)) {
                    const template = problemTemplates[buildingName];
                    const isAddition = Math.random() < 0.5;
                    
                    let num1, num2, answer, question;
                    
                    if (isAddition) {
                        // Addition problems: numbers 1-50
                        num1 = Math.floor(Math.random() * 50) + 1;
                        num2 = Math.floor(Math.random() * 50) + 1;
                        answer = num1 + num2;
                        question = template.addition(num1, num2);
                    } else {
                        // Subtraction problems: ensure positive result
                        num1 = Math.floor(Math.random() * 70) + 20; // 20-89
                        num2 = Math.floor(Math.random() * num1) + 1; // 1 to num1
                        answer = num1 - num2;
                        question = template.subtraction(num1, num2);
                    }
                    
                    this.mathProblems[buildingName] = {
                        question: question,
                        answer: answer
                    };
                }
            }
            
            initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.log('Web Audio API not supported');
                    this.audioContext = null;
                }
            }
            
            playPieceCollectedChime() {
                if (!this.audioContext) {
                    console.log('No audio context available');
                    return;
                }
                
                console.log('Playing piece collected chime, audio context state:', this.audioContext.state);
                
                // Resume audio context if suspended (required by browser policies)
                if (this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
                
                const now = this.audioContext.currentTime;
                
                // Create a short, pleasant chime sound
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                // Sweet chime notes: C5 -> E5 -> G5
                const frequencies = [523.25, 659.25, 783.99];
                
                frequencies.forEach((freq, index) => {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    
                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    osc.frequency.setValueAtTime(freq, now + index * 0.2);
                    osc.type = 'sine';
                    
                    // Envelope: quick attack, gentle decay
                    gain.gain.setValueAtTime(0, now + index * 0.2);
                    gain.gain.linearRampToValueAtTime(0.3, now + index * 0.2 + 0.05);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + index * 0.2 + 0.4);
                    
                    osc.start(now + index * 0.2);
                    osc.stop(now + index * 0.2 + 0.4);
                });
            }
            
            playPuzzleCompletedMusic() {
                if (!this.audioContext) {
                    console.log('No audio context available for victory music');
                    return;
                }
                
                console.log('Playing puzzle completed music, audio context state:', this.audioContext.state);
                
                // Resume audio context if suspended
                if (this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
                
                const now = this.audioContext.currentTime;
                
                // Shorter victory melody: C4-E4-G4-C5 (simple "Ta-da!")
                const melody = [
                    { freq: 261.63, time: 0.0, duration: 0.2 },   // C4
                    { freq: 329.63, time: 0.2, duration: 0.2 },   // E4
                    { freq: 392.00, time: 0.4, duration: 0.2 },   // G4
                    { freq: 523.25, time: 0.6, duration: 0.4 }    // C5 (final note)
                ];
                
                melody.forEach(note => {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    
                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    osc.frequency.setValueAtTime(note.freq, now + note.time);
                    osc.type = 'triangle';
                    
                    // Simpler envelope that fades out properly
                    gain.gain.setValueAtTime(0, now + note.time);
                    gain.gain.linearRampToValueAtTime(0.2, now + note.time + 0.05);
                    gain.gain.linearRampToValueAtTime(0, now + note.time + note.duration);
                    
                    osc.start(now + note.time);
                    osc.stop(now + note.time + note.duration + 1); // Stop slightly after fade
                });
            }
            
            setupEventListeners() {
                canvas.focus();
                
                canvas.addEventListener('click', (e) => {
                    canvas.focus();
                    this.handleClick(e);
                    
                    // Initialize audio on first user interaction
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
                });
                
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key] = true;
                    
                    // Initialize audio on first user interaction
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
                    
                    // Prevent arrow keys from scrolling the page
                    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                        e.preventDefault();
                    }
                    
                    if (e.key === ' ' && this.currentScreen !== 'town') {
                        this.exitBuilding();
                        e.preventDefault();
                    }
                    
                    // Handle math input when in a building with a puzzle piece
                    if (this.currentScreen === 'building' && this.currentBuilding && 
                        this.buildingsWithPieces.has(this.currentBuilding.name) && 
                        !this.collectedFromBuildings.has(this.currentBuilding.name)) {
                        
                        if (e.key >= '0' && e.key <= '9') {
                            // Number input
                            if (this.currentMathAnswer === null) {
                                this.currentMathAnswer = parseInt(e.key);
                            } else {
                                this.currentMathAnswer = this.currentMathAnswer * 10 + parseInt(e.key);
                            }
                            this.mathFeedback = '';
                            e.preventDefault();
                        } else if (e.key === 'Backspace') {
                            // Delete last digit
                            if (this.currentMathAnswer !== null) {
                                this.currentMathAnswer = Math.floor(this.currentMathAnswer / 10);
                                if (this.currentMathAnswer === 0) {
                                    this.currentMathAnswer = null;
                                }
                            }
                            this.mathFeedback = '';
                            e.preventDefault();
                        } else if (e.key === 'Enter' && this.currentMathAnswer !== null) {
                            // Check answer
                            this.checkMathAnswer();
                            e.preventDefault();
                        }
                    }
                    
                    // Temporary testing: Press 'C' to complete puzzle instantly
                    if (e.key === 'c' || e.key === 'C') {
                        this.collectedPieces = this.totalPuzzlePieces;
                        // Mark all buildings as collected
                        for (const buildingName of Object.keys(this.buildingToPiece)) {
                            this.collectedFromBuildings.add(buildingName);
                        }
                        // Trigger completion sequence
                        this.currentScreen = 'puzzle';
                        this.playPuzzleCompletedMusic();
                        console.log('Puzzle completed via cheat key!');
                        e.preventDefault();
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.key] = false;
                });
            }
            
            handleClick(e) {
                if (this.currentScreen === 'puzzle') {
                    const rect = canvas.getBoundingClientRect();
                    const clickX = e.clientX - rect.left;
                    const clickY = e.clientY - rect.top;
                    
                    // Check if click is within restart button bounds
                    if (clickX >= this.restartButtonX && 
                        clickX <= this.restartButtonX + this.restartButtonWidth &&
                        clickY >= this.restartButtonY && 
                        clickY <= this.restartButtonY + this.restartButtonHeight) {
                        this.restartGame();
                    }
                }
            }
            
            checkMathAnswer() {
                const correctAnswer = this.mathProblems[this.currentBuilding.name].answer;
                
                if (this.currentMathAnswer === correctAnswer) {
                    this.mathFeedback = 'Correct! You got the puzzle piece!';
                    
                    // Play celebration chime
                    this.playPieceCollectedChime();
                    
                    // Start celebration animation
                    this.showCelebration = true;
                    this.celebrationStartTime = Date.now();
                    this.celebrationPieceNumber = this.buildingToPiece[this.currentBuilding.name];
                    
                    // Award the puzzle piece
                    this.collectedFromBuildings.add(this.currentBuilding.name);
                    this.collectedPieces++;
                    
                    // Clear math state and celebration after animation
                    setTimeout(() => {
                        this.currentMathAnswer = null;
                        this.mathFeedback = '';
                        this.showCelebration = false;
                    }, 3000);
                } else {
                    this.mathFeedback = `Try again! The answer is not ${this.currentMathAnswer}.`;
                    this.currentMathAnswer = null;
                }
            }
            
            drawCelebration() {
                if (!this.showCelebration || !this.imageLoaded) return;
                
                const elapsed = Date.now() - this.celebrationStartTime;
                const duration = 3000; // 3 seconds
                const progress = Math.min(elapsed / duration, 1);
                
                // Semi-transparent overlay
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
                
                // Celebration text
                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('üéâ Great Job! üéâ', SCREEN_WIDTH / 2, 150);
                
                // Animated puzzle piece
                const centerX = SCREEN_WIDTH / 2;
                const centerY = SCREEN_HEIGHT / 2;
                
                // Bounce and scale animation
                const bounceHeight = Math.sin(progress * Math.PI * 4) * 20 * (1 - progress);
                const scale = 0.5 + Math.sin(progress * Math.PI * 2) * 0.3;
                const rotation = progress * Math.PI * 4;
                
                const pieceSize = 120 * scale;
                const pieceY = centerY + bounceHeight;
                
                // Save canvas state for transformation
                ctx.save();
                ctx.translate(centerX, pieceY);
                ctx.rotate(rotation);
                
                // Draw the puzzle piece
                const col = this.celebrationPieceNumber % 4;
                const row = Math.floor(this.celebrationPieceNumber / 4);
                
                const sourceWidth = this.puzzleImage.width / 4;
                const sourceHeight = this.puzzleImage.height / 2;
                const sourceX = col * sourceWidth;
                const sourceY = row * sourceHeight;
                
                ctx.drawImage(
                    this.puzzleImage,
                    sourceX, sourceY, sourceWidth, sourceHeight,
                    -pieceSize/2, -pieceSize/2, pieceSize, pieceSize
                );
                
                // Sparkle border
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 4;
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#FFD700';
                ctx.strokeRect(-pieceSize/2, -pieceSize/2, pieceSize, pieceSize);
                
                // Restore canvas state
                ctx.restore();
                
                // Success message
                ctx.fillStyle = COLORS.WHITE;
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`You earned ${this.puzzleName} piece #${this.celebrationPieceNumber + 1}!`, SCREEN_WIDTH / 2, centerY + 100);
                
                // Sparkling particles
                for (let i = 0; i < 20; i++) {
                    const angle = (i / 20) * Math.PI * 2 + elapsed * 0.01;
                    const radius = 100 + Math.sin(elapsed * 0.01 + i) * 20;
                    const sparkleX = centerX + Math.cos(angle) * radius;
                    const sparkleY = centerY + Math.sin(angle) * radius;
                    
                    ctx.fillStyle = '#FFD700';
                    ctx.font = '20px Arial';
                    ctx.fillText('‚ú®', sparkleX, sparkleY);
                }
            }
            
            restartGame() {
                // Reset all game state
                this.collectedPieces = 0;
                this.collectedFromBuildings.clear();
                this.currentScreen = 'town';
                this.currentBuilding = null;
                
                // Reset math state
                this.currentMathAnswer = null;
                this.mathFeedback = '';
                
                // Reset celebration state
                this.showCelebration = false;
                this.puzzleCompletedMusicPlayed = false;
                
                // Randomly reassign puzzle pieces
                this.assignPuzzlePieces();
                
                // Reset player position to starting location
                const startPos = gridToScreen(7, 4);
                this.player.x = startPos.x + 30;
                this.player.y = startPos.y + 30;
            }
            
            handleInput() {
                let dx = 0, dy = 0;
                
                if (this.keys['ArrowLeft']) dx = -1;
                if (this.keys['ArrowRight']) dx = 1;
                if (this.keys['ArrowUp']) dy = -1;
                if (this.keys['ArrowDown']) dy = 1;
                
                this.player.move(dx, dy, this);
            }
            
            canMoveTo(x, y, size) {
                if (this.currentScreen !== 'town') {
                    // Inside building - can move anywhere except outside walls (but allow access to exit door)
                    return x >= 58 && y >= 58 && 
                           x + size <= SCREEN_WIDTH - 58 && 
                           y + size <= SCREEN_HEIGHT - 50; // Allow closer to bottom for exit door
                }
                
                // Outside - check valid position
                return this.isValidPosition(x, y, size);
            }
            
            isValidPosition(x, y, size) {
                const playerRight = x + size;
                const playerBottom = y + size;
                
                // Check game area bounds (not sidebar)
                if (x < GAME_OFFSET_X || y < 0 || playerRight > SCREEN_WIDTH || playerBottom > SCREEN_HEIGHT) {
                    return false;
                }
                
                // Check building collisions
                for (const building of this.buildings) {
                    if (x < building.x + building.width &&
                        playerRight > building.x &&
                        y < building.y + building.height &&
                        playerBottom > building.y) {
                        return false;
                    }
                }
                
                // Check if player is on roads or driveways (not grass)
                return this.isOnRoadOrDriveway(x, y, size);
            }
            
            isOnRoadOrDriveway(x, y, size) {
                const playerRight = x + size;
                const playerBottom = y + size;
                
                // Road dimensions
                const roadHeight = CELL_HEIGHT * 0.75;
                const roadVerticalOffset = CELL_HEIGHT * 0.125;
                const roadWidth = CELL_WIDTH * 0.75;
                const roadHorizontalOffset = CELL_WIDTH * 0.125;
                
                // Check horizontal roads (rows 1, 4, 7)
                const roadRows = [1, 4, 7];
                for (const row of roadRows) {
                    const roadPos = gridToScreen(1, row);
                    const roadY = roadPos.y + roadVerticalOffset;
                    
                    if (y >= roadY && playerBottom <= roadY + roadHeight) {
                        return true;
                    }
                }
                
                // Check vertical roads (columns 4, 8, 11)
                const roadCols = [4, 8, 11];
                for (const col of roadCols) {
                    const roadPos = gridToScreen(col, 1);
                    const roadX = roadPos.x + roadHorizontalOffset;
                    
                    if (x >= roadX && playerRight <= roadX + roadWidth) {
                        return true;
                    }
                }
                
                // Check driveways
                for (const building of this.buildings) {
                    if (x >= building.drivewayX && 
                        playerRight <= building.drivewayX + building.drivewayWidth &&
                        y >= building.drivewayY && 
                        playerBottom <= building.drivewayY + building.drivewayHeight+50) {
                        return true;
                    }
                }
                
                return false; // Cannot move on grass
            }
            
            drawTown() {
                // Draw sidebar background
                ctx.fillStyle = '#2c3e50';
                ctx.fillRect(0, 0, SIDEBAR_WIDTH, SCREEN_HEIGHT);
                
                // Draw sidebar border
                ctx.strokeStyle = '#34495e';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(SIDEBAR_WIDTH, 0);
                ctx.lineTo(SIDEBAR_WIDTH, SCREEN_HEIGHT);
                ctx.stroke();
                
                // Draw grass background for game area
                ctx.fillStyle = COLORS.GRASS;
                ctx.fillRect(GAME_OFFSET_X, 0, GAME_WIDTH, SCREEN_HEIGHT);
                
                // Draw horizontal roads on rows 1, 4, and 7 (75% of cell height)
                ctx.fillStyle = COLORS.ROAD;
                
                const roadRows = [1, 4, 7];
                const roadHeight = CELL_HEIGHT * 0.75;
                const roadVerticalOffset = CELL_HEIGHT * 0.125; // Center the road in the cell
                
                for (const row of roadRows) {
                    const roadPos = gridToScreen(1, row);
                    ctx.fillRect(GAME_OFFSET_X, roadPos.y + roadVerticalOffset, GAME_WIDTH, roadHeight);
                }
                
                // Draw vertical roads on columns 4, 8, and 11 (75% of cell width)
                const roadCols = [4, 8, 11];
                const roadWidth = CELL_WIDTH * 0.75;
                const roadHorizontalOffset = CELL_WIDTH * 0.125; // Center the road in the cell
                
                for (const col of roadCols) {
                    const roadPos = gridToScreen(col, 1);
                    ctx.fillRect(roadPos.x + roadHorizontalOffset, 0, roadWidth, SCREEN_HEIGHT);
                }
                
                // Draw road markings
                ctx.fillStyle = COLORS.WHITE;
                
                // Horizontal road markings
                for (const row of roadRows) {
                    const roadPos = gridToScreen(1, row);
                    const roadCenterY = roadPos.y + roadVerticalOffset + roadHeight / 2;
                    
                    for (let i = GAME_OFFSET_X; i < SCREEN_WIDTH; i += 60) {
                        ctx.fillRect(i, roadCenterY - 2, 30, 4);
                    }
                }
                
                // Vertical road markings
                for (const col of roadCols) {
                    const roadPos = gridToScreen(col, 1);
                    const roadCenterX = roadPos.x + roadHorizontalOffset + roadWidth / 2;
                    
                    for (let i = 0; i < SCREEN_HEIGHT; i += 60) {
                        ctx.fillRect(roadCenterX - 2, i, 4, 30);
                    }
                }
                
                // Draw buildings
                for (const building of this.buildings) {
                    building.draw();
                }
                
                // Draw player
                this.player.draw();
                
                // Draw inventory UI
                this.drawInventory();
            }
            
            checkBuildingEntry() {
                for (const building of this.buildings) {
                    if (building.checkDoorCollision(this.player)) {
                        this.enterBuilding(building);
                        return;
                    }
                }
            }
            
            enterBuilding(building) {
                this.currentScreen = 'building';
                this.currentBuilding = building;
                // Position player inside building
                this.player.x = SCREEN_WIDTH / 2 - this.player.size / 2;
                this.player.y = SCREEN_HEIGHT - 100;
                
                // Reset math state when entering a building
                this.currentMathAnswer = null;
                this.mathFeedback = '';
                this.showCelebration = false;
            }
            
            exitBuilding() {
                if (this.currentBuilding) {
                    this.currentScreen = 'town';
                    // Position player on the building's driveway
                    this.player.x = this.currentBuilding.drivewayX + (this.currentBuilding.drivewayWidth - this.player.size) / 2;
                    this.player.y = this.currentBuilding.drivewayY + 10;
                    this.currentBuilding = null;
                    
                    // Reset math state when exiting
                    this.currentMathAnswer = null;
                    this.mathFeedback = '';
                    this.showCelebration = false;
                }
            }
            
            checkBuildingExit() {
                if (this.currentBuilding && this.currentBuilding.checkInteriorExit(this.player)) {
                    this.exitBuilding();
                }
            }
            
            checkPuzzlePieceCollection() {
                if (this.currentBuilding && this.currentBuilding.checkPuzzlePieceCollection(this.player, this)) {
                    if (!this.collectedFromBuildings.has(this.currentBuilding.name)) {
                        this.collectedFromBuildings.add(this.currentBuilding.name);
                        this.collectedPieces++;
                    }
                }
            }
            
            drawInventory() {
                // Sidebar title
                ctx.fillStyle = COLORS.WHITE;
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${this.puzzleName} Puzzle`, SIDEBAR_WIDTH / 2, 30);
                
                // Collection count
                ctx.font = 'bold 16px Arial';
                ctx.fillText(`${this.collectedPieces} of ${this.totalPuzzlePieces} pieces`, SIDEBAR_WIDTH / 2, 50);
                
                // Live puzzle assembly area
                const puzzleStartY = 70;
                const puzzleWidth = SIDEBAR_WIDTH - 20;
                const puzzleHeight = puzzleWidth * 0.75; // 4:3 aspect ratio
                const puzzleX = 10;
                
                // Puzzle background
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.fillRect(puzzleX, puzzleStartY, puzzleWidth, puzzleHeight);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.strokeRect(puzzleX, puzzleStartY, puzzleWidth, puzzleHeight);
                
                // Draw collected puzzle pieces in their correct positions
                if (this.imageLoaded) {
                    const pieceWidth = puzzleWidth / 4;
                    const pieceHeight = puzzleHeight / 2;
                    
                    // Draw grid lines
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.lineWidth = 1;
                    
                    // Vertical grid lines
                    for (let i = 1; i < 4; i++) {
                        const x = puzzleX + (i * pieceWidth);
                        ctx.beginPath();
                        ctx.moveTo(x, puzzleStartY);
                        ctx.lineTo(x, puzzleStartY + puzzleHeight);
                        ctx.stroke();
                    }
                    
                    // Horizontal grid line
                    const y = puzzleStartY + puzzleHeight / 2;
                    ctx.beginPath();
                    ctx.moveTo(puzzleX, y);
                    ctx.lineTo(puzzleX + puzzleWidth, y);
                    ctx.stroke();
                    
                    // Draw collected pieces
                    for (const [buildingName, pieceNumber] of Object.entries(this.buildingToPiece)) {
                        if (this.collectedFromBuildings.has(buildingName)) {
                            const col = pieceNumber % 4;
                            const row = Math.floor(pieceNumber / 4);
                            
                            const destX = puzzleX + (col * pieceWidth);
                            const destY = puzzleStartY + (row * pieceHeight);
                            
                            // Calculate source coordinates
                            const sourceWidth = this.puzzleImage.width / 4;
                            const sourceHeight = this.puzzleImage.height / 2;
                            const sourceX = col * sourceWidth;
                            const sourceY = row * sourceHeight;
                            
                            // Draw the piece
                            ctx.drawImage(
                                this.puzzleImage,
                                sourceX, sourceY, sourceWidth, sourceHeight,
                                destX + 1, destY + 1, pieceWidth - 2, pieceHeight - 2
                            );
                            
                            // Add piece border
                            ctx.strokeStyle = '#4CAF50';
                            ctx.lineWidth = 2;
                            ctx.strokeRect(destX + 1, destY + 1, pieceWidth - 2, pieceHeight - 2);
                        }
                    }
                    
                    // Draw empty piece outlines for uncollected pieces
                    for (let pieceNumber = 0; pieceNumber < 8; pieceNumber++) {
                        const collected = Object.entries(this.buildingToPiece).some(([buildingName, pNum]) => 
                            pNum === pieceNumber && this.collectedFromBuildings.has(buildingName)
                        );
                        
                        if (!collected) {
                            const col = pieceNumber % 4;
                            const row = Math.floor(pieceNumber / 4);
                            
                            const destX = puzzleX + (col * pieceWidth);
                            const destY = puzzleStartY + (row * pieceHeight);
                            
                            // Draw empty piece outline
                            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                            ctx.lineWidth = 1;
                            ctx.setLineDash([5, 5]);
                            ctx.strokeRect(destX + 1, destY + 1, pieceWidth - 2, pieceHeight - 2);
                            ctx.setLineDash([]);
                            
                            // Piece number
                            ctx.font = '12px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                            ctx.fillText(`${pieceNumber + 1}`, destX + pieceWidth/2, destY + pieceHeight/2 + 3);
                        }
                    }
                } else {
                    // Fallback if image not loaded
                    ctx.font = '24px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.fillText(this.puzzleEmoji, SIDEBAR_WIDTH / 2, puzzleStartY + puzzleHeight/2);
                    ctx.font = '12px Arial';
                    ctx.fillText('Loading...', SIDEBAR_WIDTH / 2, puzzleStartY + puzzleHeight/2 + 30);
                }
                
                // Progress bar at bottom
                const progressY = puzzleStartY + puzzleHeight + 20;
                const progressWidth = SIDEBAR_WIDTH - 40;
                const progressHeight = 8;
                const progressX = 20;
                
                // Progress background
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.fillRect(progressX, progressY, progressWidth, progressHeight);
                
                // Progress fill
                const progressPercent = this.collectedPieces / this.totalPuzzlePieces;
                ctx.fillStyle = '#4CAF50';
                ctx.fillRect(progressX, progressY, progressWidth * progressPercent, progressHeight);
                
                // Progress border
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 1;
                ctx.strokeRect(progressX, progressY, progressWidth, progressHeight);
                
                // Instructions
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = '#BBB';
                ctx.fillText('Collect pieces from buildings', SIDEBAR_WIDTH / 2, progressY + 25);
            }
            
            update() {
                this.handleInput();
                
                if (this.currentScreen === 'town') {
                    this.checkBuildingEntry();
                } else {
                    this.checkBuildingExit();
                    
                    // Check if all puzzle pieces collected
                    if (this.collectedPieces >= this.totalPuzzlePieces) {
                        this.currentScreen = 'puzzle';
                        // Play victory music only once when puzzle is completed
                        if (!this.puzzleCompletedMusicPlayed) {
                            this.playPuzzleCompletedMusic();
                            this.puzzleCompletedMusicPlayed = true;
                        }
                    }
                }
            }
            
            draw() {
                ctx.clearRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
                
                if (this.currentScreen === 'town') {
                    this.drawTown();
                } else if (this.currentScreen === 'puzzle') {
                    this.drawPuzzleScreen();
                } else if (this.currentBuilding) {
                    this.currentBuilding.drawInterior(this);
                    this.player.draw();
                }
                
                // Draw celebration overlay if active
                if (this.showCelebration) {
                    this.drawCelebration();
                }
            }
            
            drawPuzzleScreen() {
                // Clear screen with puzzle background
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
                
                // Title
                ctx.fillStyle = COLORS.WHITE;
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`üéâ ${this.puzzleName} Puzzle Complete! üéâ`, SCREEN_WIDTH / 2, 150);
                
                // Congratulations message
                ctx.font = '24px Arial';
                ctx.fillText('You collected all the puzzle pieces!', SCREEN_WIDTH / 2, 200);
                
                // Show completed unicorn puzzle
                const puzzleWidth = 320;
                const puzzleHeight = 240;
                const puzzleX = SCREEN_WIDTH / 2 - puzzleWidth / 2;
                const puzzleY = 230;
                
                if (this.imageLoaded) {
                    // Draw the complete puzzle image
                    ctx.drawImage(this.puzzleImage, puzzleX, puzzleY, puzzleWidth, puzzleHeight);
                    
                    // Draw grid lines to show puzzle pieces
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 3;
                    
                    // Vertical lines
                    for (let i = 1; i < 4; i++) {
                        const x = puzzleX + (i * puzzleWidth / 4);
                        ctx.beginPath();
                        ctx.moveTo(x, puzzleY);
                        ctx.lineTo(x, puzzleY + puzzleHeight);
                        ctx.stroke();
                    }
                    
                    // Horizontal line
                    const y = puzzleY + puzzleHeight / 2;
                    ctx.beginPath();
                    ctx.moveTo(puzzleX, y);
                    ctx.lineTo(puzzleX + puzzleWidth, y);
                    ctx.stroke();
                    
                    // Outer border
                    ctx.strokeStyle = COLORS.BLACK;
                    ctx.lineWidth = 4;
                    ctx.strokeRect(puzzleX, puzzleY, puzzleWidth, puzzleHeight);
                } else {
                    // Fallback if image didn't load
                    ctx.fillStyle = '#FFF8DC';
                    ctx.fillRect(puzzleX, puzzleY, puzzleWidth, puzzleHeight);
                    ctx.strokeStyle = COLORS.BLACK;
                    ctx.lineWidth = 3;
                    ctx.strokeRect(puzzleX, puzzleY, puzzleWidth, puzzleHeight);
                    
                    ctx.font = '80px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillStyle = COLORS.BLACK;
                    ctx.fillText(this.puzzleEmoji, SCREEN_WIDTH / 2, puzzleY + puzzleHeight/2 + 25);
                }
                
                // Attribution under the puzzle
                ctx.fillStyle = '#888';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                if (this.puzzleType === 'cat') {
                    ctx.fillText('Cat Graphics Vectors by Vecteezy', SCREEN_WIDTH / 2, puzzleY + puzzleHeight + 20);
                } else {
                    ctx.fillText('Unicorn Graphics Vectors by Vecteezy', SCREEN_WIDTH / 2, puzzleY + puzzleHeight + 20);
                }
                
                // Play Again Button
                this.restartButtonX = SCREEN_WIDTH / 2 - 100;
                this.restartButtonY = 520;
                this.restartButtonWidth = 200;
                this.restartButtonHeight = 50;
                
                // Button background
                ctx.fillStyle = '#4CAF50';
                ctx.fillRect(this.restartButtonX, this.restartButtonY, this.restartButtonWidth, this.restartButtonHeight);
                ctx.strokeStyle = COLORS.WHITE;
                ctx.lineWidth = 3;
                ctx.strokeRect(this.restartButtonX, this.restartButtonY, this.restartButtonWidth, this.restartButtonHeight);
                
                // Button text
                ctx.fillStyle = COLORS.WHITE;
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('üîÑ Play Again', SCREEN_WIDTH / 2, this.restartButtonY + 32);
                
                // Thank you message
                ctx.fillStyle = '#BBB';
                ctx.font = '18px Arial';
                ctx.fillText('Thank you for playing Town Explorer!', SCREEN_WIDTH / 2, 600);
            }
            
            gameLoop() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // Start the game
        const game = new Game();
        game.gameLoop();
    </script>
</body>
</html>