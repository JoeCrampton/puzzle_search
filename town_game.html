<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Town Explorer</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background-color: #2c3e50;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #gameCanvas {
            border: 3px solid #34495e;
            background-color: #ecf0f1;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            outline: none;
        }
        
        h1 {
            color: #ecf0f1;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .instructions {
            color: #bdc3c7;
            text-align: center;
            margin-top: 10px;
            font-size: 14px;
            max-width: 600px;
        }
    </style>
</head>
<body>
    <h1>üèòÔ∏è Town Explorer</h1>
    <canvas id="gameCanvas" width="1000" height="600" tabindex="0"></canvas>
    <div class="instructions">
        <p>Use arrow keys to move ‚Ä¢ Walk on roads and driveways ‚Ä¢ Enter buildings through doors ‚Ä¢ Press SPACE to exit buildings</p>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        const SCREEN_WIDTH = 1000;
        const SCREEN_HEIGHT = 600;
        const SIDEBAR_WIDTH = SCREEN_WIDTH * 0.25; // 25% for left sidebar
        const GAME_WIDTH = SCREEN_WIDTH * 0.75; // 75% for game area
        const GAME_OFFSET_X = SIDEBAR_WIDTH; // Game starts after sidebar
        
        // Grid system: 14 columns √ó 9 rows (now within the 75% game area)
        const GRID_COLS = 14;
        const GRID_ROWS = 9;
        const CELL_WIDTH = GAME_WIDTH / GRID_COLS;  // ~53px per cell in game area
        const CELL_HEIGHT = SCREEN_HEIGHT / GRID_ROWS; // ~78px per cell
        
        const DRIVEWAY_WIDTH = 40;
        const DRIVEWAY_HEIGHT = 17;
        const DOOR_SIZE = 20;
        
        // Colors
        const COLORS = {
            GRASS: '#4CAF50',
            ROAD: '#616161',
            DRIVEWAY: '#757575',
            PLAYER: '#2196F3',
            DOOR: '#8D6E63',
            WHITE: '#FFFFFF',
            BLACK: '#000000',
            
            // Building colors
            FIRE_STATION: '#F44336',
            POLICE: '#3F51B5',
            HOSPITAL: '#FF9800',
            SCHOOL: '#9C27B0',
            LIBRARY: '#607D8B',
            RESTAURANT: '#E91E63',
            BANK: '#795548',
            MUSEUM: '#009688',
            POST_OFFICE: '#FF5722',
            GROCERY: '#8BC34A',
            GAS_STATION: '#FFC107',
            PARK_OFFICE: '#4CAF50'
        };
        
        // Convert grid coordinates (1,1 = bottom left) to screen coordinates within game area
        function gridToScreen(gridX, gridY) {
            return {
                x: GAME_OFFSET_X + (gridX - 1) * CELL_WIDTH,
                y: SCREEN_HEIGHT - (gridY * CELL_HEIGHT)
            };
        }
        
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = 14;
                this.speed = 3;
            }
            
            move(dx, dy, game) {
                const newX = this.x + dx * this.speed;
                const newY = this.y + dy * this.speed;
                
                if (game.canMoveTo(newX, this.y, this.size)) {
                    this.x = newX;
                }
                if (game.canMoveTo(this.x, newY, this.size)) {
                    this.y = newY;
                }
            }
            
            draw() {
                // Player as a blue circle with simple face
                ctx.fillStyle = COLORS.PLAYER;
                ctx.beginPath();
                ctx.arc(this.x + this.size/2, this.y + this.size/2, this.size/2, 0, Math.PI * 2);
                ctx.fill();
                
                // Eyes
                ctx.fillStyle = COLORS.WHITE;
                ctx.beginPath();
                ctx.arc(this.x + this.size/2 - 3, this.y + this.size/2 - 2, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(this.x + this.size/2 + 3, this.y + this.size/2 - 2, 2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            getBounds() {
                return {
                    x: this.x,
                    y: this.y,
                    width: this.size,
                    height: this.size
                };
            }
        }
        
        class Building {
            constructor(gridX, gridY, gridWidth, gridHeight, color, name, type) {
                this.gridX = gridX;
                this.gridY = gridY;
                this.gridWidth = gridWidth;
                this.gridHeight = gridHeight;
                this.color = color;
                this.name = name;
                this.type = type;
                
                // Convert grid coordinates to screen coordinates
                const screenPos = gridToScreen(gridX, gridY);
                this.x = screenPos.x + 5; // 5px margin within cell
                this.y = screenPos.y + 5;
                this.width = gridWidth * CELL_WIDTH - 10; // 10px total margin
                this.height = gridHeight * CELL_HEIGHT - 10;
                
                // Door position (bottom center of building)
                this.doorX = this.x + (this.width - DOOR_SIZE) / 2;
                this.doorY = this.y + this.height;
                
                // Calculate driveway to nearest road
                this.calculateDriveway();
            }
            
            calculateDriveway() {
                // Determine which road to connect to based on building position
                let roadRow;
                if (this.gridY >= 8) {
                    // Top buildings (rows 8-9) connect to road on row 7
                    roadRow = 7;
                } else if (this.gridY >= 5) {
                    // Middle buildings (rows 5-6) connect to road on row 4
                    roadRow = 4;
                } else {
                    // Bottom buildings (rows 2-3) connect to road on row 1
                    roadRow = 1;
                }
                
                // Calculate the actual road position with the centered narrow roads
                const roadScreenPos = gridToScreen(1, roadRow);
                const roadHeight = CELL_HEIGHT * 0.75;
                const roadVerticalOffset = CELL_HEIGHT * 0.125;
                const roadY = roadScreenPos.y + roadVerticalOffset;
                
                // Driveway positioning
                this.drivewayX = this.doorX + (DOOR_SIZE - DRIVEWAY_WIDTH) / 2;
                this.drivewayWidth = DRIVEWAY_WIDTH;
                
                // Calculate driveway to just touch road edge (not overlap)
               
                    // All buildings: driveway goes down from door to top edge of road
                    this.drivewayY = this.doorY + 1;
                    this.drivewayHeight = roadY - this.drivewayY;

            }
            
            
            getBuildingIcon() {
                // Return appropriate emoji icon based on building type
                switch(this.type) {
                    case 'fire': return 'üöí';
                    case 'police': return 'üëÆ';
                    case 'hospital': return 'üè•';
                    case 'school': return 'üè´';
                    case 'library': return 'üìö';
                    case 'restaurant': return 'üçΩÔ∏è';
                    case 'bank': return 'üè¶';
                    case 'museum': return 'üèõÔ∏è';
                    case 'post': return 'üìÆ';
                    case 'grocery': return 'üõí';
                    case 'gas': return '‚õΩ';
                    case 'park': return 'üå≥';
                    case 'clinic': return '‚öïÔ∏è';
                    default: return 'üè¢';
                }
            }
            
            draw() {
                // Simple background rectangle
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.strokeStyle = COLORS.BLACK;
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, this.y, this.width, this.height);
                
                // Building icon (large emoji in center)
                const icon = this.getBuildingIcon();
                ctx.font = '48px Arial';
                ctx.textAlign = 'center';
                const iconX = this.x + this.width / 2;
                const iconY = this.y + this.height / 2 + 15; // Offset for text baseline
                ctx.fillText(icon, iconX, iconY);
                
                // Building label
                ctx.fillStyle = COLORS.WHITE;
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                const textX = this.x + this.width / 2;
                const textY = this.y + this.height - 8;
                
                // Text background for readability
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                const textWidth = ctx.measureText(this.name).width;
                ctx.fillRect(textX - textWidth/2 - 4, textY - 12, textWidth + 8, 16);
                
                ctx.fillStyle = COLORS.WHITE;
                ctx.fillText(this.name, textX, textY);
                
                // Door
                ctx.fillStyle = COLORS.DOOR;
                ctx.fillRect(this.doorX, this.doorY, DOOR_SIZE, 8);
                ctx.strokeStyle = COLORS.BLACK;
                ctx.lineWidth = 1;
                ctx.strokeRect(this.doorX, this.doorY, DOOR_SIZE, 8);
                
                // Door handle
                ctx.fillStyle = COLORS.WHITE;
                ctx.beginPath();
                ctx.arc(this.doorX + DOOR_SIZE - 3, this.doorY + 4, 1.5, 0, Math.PI * 2);
                ctx.fill();
                
                // Driveway
                ctx.fillStyle = COLORS.DRIVEWAY;
                ctx.fillRect(this.drivewayX, this.drivewayY, this.drivewayWidth, this.drivewayHeight);
            }
            
            checkDoorCollision(player) {
                const playerBounds = player.getBounds();
                return playerBounds.x < this.doorX + DOOR_SIZE &&
                       playerBounds.x + playerBounds.width > this.doorX &&
                       playerBounds.y < this.doorY + 8 &&
                       playerBounds.y + playerBounds.height > this.doorY;
            }
            
            drawInterior(game) {
                // Clear screen with interior color
                ctx.fillStyle = '#F5F5F5';
                ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
                
                // Building outline (walls)
                ctx.strokeStyle = COLORS.BLACK;
                ctx.lineWidth = 8;
                ctx.strokeRect(50, 50, SCREEN_WIDTH - 100, SCREEN_HEIGHT - 100);
                
                // Building icon (left of title)
                const icon = this.getBuildingIcon();
                ctx.font = '48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(icon, SCREEN_WIDTH / 2 - 100, 130);
                
                // Building name (to the right of icon)
                ctx.fillStyle = COLORS.BLACK;
                ctx.font = '36px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(this.name, SCREEN_WIDTH / 2 - 50, 120);
                
                // Draw puzzle piece if this building has one and it's not collected
                if (game.buildingsWithPieces.has(this.name) && !game.collectedFromBuildings.has(this.name)) {
                    this.drawPuzzlePiece(game.buildingToPiece[this.name], game);
                }
                
                // Exit door at bottom
                ctx.fillStyle = COLORS.DOOR;
                ctx.fillRect((SCREEN_WIDTH - 30) / 2, SCREEN_HEIGHT - 58, 30, 8);
                ctx.strokeStyle = COLORS.BLACK;
                ctx.lineWidth = 2;
                ctx.strokeRect((SCREEN_WIDTH - 30) / 2, SCREEN_HEIGHT - 58, 30, 8);
                
                // Instructions
                ctx.fillStyle = '#666';
                ctx.font = '18px Arial';
                ctx.textAlign = 'center';
                if (game.collectedFromBuildings.has(this.name)) {
                    ctx.fillText('Puzzle piece collected! ‚Ä¢ Walk to door or press SPACE to exit', SCREEN_WIDTH / 2, SCREEN_HEIGHT - 20);
                } else if (game.buildingsWithPieces.has(this.name)) {
                    ctx.fillText('Walk to puzzle piece to collect it ‚Ä¢ Walk to door or press SPACE to exit', SCREEN_WIDTH / 2, SCREEN_HEIGHT - 20);
                } else {
                    ctx.fillText('No puzzle piece here ‚Ä¢ Walk to door or press SPACE to exit', SCREEN_WIDTH / 2, SCREEN_HEIGHT - 20);
                }
            }
            
            drawPuzzlePiece(pieceNumber, game) {
                // Draw a puzzle piece in the center of the room
                const pieceX = SCREEN_WIDTH / 2;
                const pieceY = SCREEN_HEIGHT / 2;
                const pieceSize = 80;
                
                if (game.imageLoaded) {
                    // Calculate source coordinates for this piece (2x4 grid)
                    const col = pieceNumber % 4;
                    const row = Math.floor(pieceNumber / 4);
                    
                    const sourceWidth = game.unicornImage.width / 4;
                    const sourceHeight = game.unicornImage.height / 2;
                    const sourceX = col * sourceWidth;
                    const sourceY = row * sourceHeight;
                    
                    // Draw the image piece
                    ctx.drawImage(
                        game.unicornImage,
                        sourceX, sourceY, sourceWidth, sourceHeight,
                        pieceX - pieceSize/2, pieceY - pieceSize/2, pieceSize, pieceSize
                    );
                    
                    // Add puzzle piece border
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(pieceX - pieceSize/2, pieceY - pieceSize/2, pieceSize, pieceSize);
                    
                    // Inner black border for definition
                    ctx.strokeStyle = COLORS.BLACK;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(pieceX - pieceSize/2, pieceY - pieceSize/2, pieceSize, pieceSize);
                } else {
                    // Fallback: draw colored square with piece number
                    const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F'];
                    
                    ctx.fillStyle = colors[pieceNumber % colors.length];
                    ctx.fillRect(pieceX - pieceSize/2, pieceY - pieceSize/2, pieceSize, pieceSize);
                    ctx.strokeStyle = COLORS.BLACK;
                    ctx.lineWidth = 3;
                    ctx.strokeRect(pieceX - pieceSize/2, pieceY - pieceSize/2, pieceSize, pieceSize);
                }
                
                // Piece number label
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillRect(pieceX - 15, pieceY + pieceSize/2 - 15, 30, 20);
                ctx.strokeStyle = COLORS.BLACK;
                ctx.lineWidth = 1;
                ctx.strokeRect(pieceX - 15, pieceY + pieceSize/2 - 15, 30, 20);
                
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = COLORS.BLACK;
                ctx.fillText(`${pieceNumber + 1}`, pieceX, pieceY + pieceSize/2 - 2);
            }
            
            checkPuzzlePieceCollection(player, game) {
                // Check if this building has a puzzle piece and it's not collected
                if (!game.buildingsWithPieces.has(this.name) || game.collectedFromBuildings.has(this.name)) {
                    return false;
                }
                
                const playerBounds = player.getBounds();
                const pieceX = SCREEN_WIDTH / 2;
                const pieceY = SCREEN_HEIGHT / 2;
                
                const distance = Math.sqrt(
                    Math.pow(playerBounds.x + playerBounds.width/2 - pieceX, 2) +
                    Math.pow(playerBounds.y + playerBounds.height/2 - pieceY, 2)
                );
                
                return distance < 35; // Close enough to collect
            }
            
            checkInteriorExit(player) {
                const playerBounds = player.getBounds();
                const exitDoorX = (SCREEN_WIDTH - 30) / 2;
                const exitDoorY = SCREEN_HEIGHT - 58;
                
                // Check if player is touching the exit door
                return playerBounds.x < exitDoorX + 100 &&
                       playerBounds.x + playerBounds.width > exitDoorX &&
                       playerBounds.y < exitDoorY + 100 &&
                       playerBounds.y + playerBounds.height > exitDoorY;
            }
        }
        
        class Game {
            constructor() {
                // Start player on road (row 4)
                const startPos = gridToScreen(7, 4);
                this.player = new Player(startPos.x + 30, startPos.y + 30);
                this.currentScreen = 'town';
                this.currentBuilding = null;
                this.keys = {};
                this.buildings = this.createBuildings();
                
                // Puzzle system
                this.totalPuzzlePieces = 8; // 8 pieces of unicorn puzzle
                this.collectedPieces = 0;
                this.collectedFromBuildings = new Set(); // Track which buildings we've collected from
                
                // Load unicorn image
                this.unicornImage = new Image();
                this.unicornImage.src = 'vecteezy_unicorn-strolling-on-the-beach-cartoon-clipart_6823393.jpg';
                this.imageLoaded = false;
                
                this.unicornImage.onload = () => {
                    this.imageLoaded = true;
                    console.log('Unicorn image loaded successfully');
                };
                
                this.unicornImage.onerror = () => {
                    console.error('Failed to load unicorn image');
                    this.imageLoaded = false;
                };
                
                // Randomly assign 8 puzzle pieces to buildings
                this.assignPuzzlePieces();
                
                this.setupEventListeners();
            }
            
            createBuildings() {
                return [
                    // Bottom row buildings (rows 2-3)
                    new Building(2, 3, 2, 2, COLORS.FIRE_STATION, 'Fire Station', 'fire'),
                    new Building(5, 3, 2, 2, COLORS.POLICE, 'Police Station', 'police'),
                    new Building(9, 3, 2, 2, COLORS.GROCERY, 'Grocery Store', 'grocery'),
                    new Building(12, 3, 2, 2, COLORS.BANK, 'Bank', 'bank'),
                    
                    // Middle row buildings (rows 5-6)
                    new Building(2, 6, 2, 2, COLORS.RESTAURANT, 'Restaurant', 'restaurant'),
                    new Building(5, 6, 3, 2, COLORS.MUSEUM, 'Museum', 'museum'), // 3x2 building
                    new Building(9, 6, 2, 2, COLORS.POST_OFFICE, 'Post Office', 'post'),
                    new Building(12, 6, 2, 2, COLORS.LIBRARY, 'Library', 'library'),
                    
                    // Top row buildings (rows 8-9)
                    new Building(2, 9, 2, 2, COLORS.HOSPITAL, 'Hospital', 'hospital'),
                    new Building(5, 9, 3, 2, COLORS.GAS_STATION, 'Gas Station', 'gas'), // 3x2 building
                    new Building(9, 9, 2, 2, COLORS.SCHOOL, 'School', 'school'),
                    new Building(12, 9, 2, 2, COLORS.PARK_OFFICE, 'Park Office', 'park')
                ];
            }
            
            assignPuzzlePieces() {
                // Create array of all building names
                const allBuildings = this.buildings.map(b => b.name);
                
                // Shuffle array and take first 8 buildings
                const shuffled = allBuildings.sort(() => Math.random() - 0.5);
                this.buildingsWithPieces = new Set(shuffled.slice(0, 8));
                
                // Map each selected building to a puzzle piece number
                this.buildingToPiece = {};
                shuffled.slice(0, 8).forEach((buildingName, index) => {
                    this.buildingToPiece[buildingName] = index;
                });
            }
            
            setupEventListeners() {
                canvas.focus();
                
                canvas.addEventListener('click', (e) => {
                    canvas.focus();
                    this.handleClick(e);
                });
                
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key] = true;
                    
                    // Prevent arrow keys from scrolling the page
                    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                        e.preventDefault();
                    }
                    
                    if (e.key === ' ' && this.currentScreen !== 'town') {
                        this.exitBuilding();
                        e.preventDefault();
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.key] = false;
                });
            }
            
            handleClick(e) {
                if (this.currentScreen === 'puzzle') {
                    const rect = canvas.getBoundingClientRect();
                    const clickX = e.clientX - rect.left;
                    const clickY = e.clientY - rect.top;
                    
                    // Check if click is within restart button bounds
                    if (clickX >= this.restartButtonX && 
                        clickX <= this.restartButtonX + this.restartButtonWidth &&
                        clickY >= this.restartButtonY && 
                        clickY <= this.restartButtonY + this.restartButtonHeight) {
                        this.restartGame();
                    }
                }
            }
            
            restartGame() {
                // Reset all game state
                this.collectedPieces = 0;
                this.collectedFromBuildings.clear();
                this.currentScreen = 'town';
                this.currentBuilding = null;
                
                // Randomly reassign puzzle pieces
                this.assignPuzzlePieces();
                
                // Reset player position to starting location
                const startPos = gridToScreen(7, 4);
                this.player.x = startPos.x + 30;
                this.player.y = startPos.y + 30;
            }
            
            handleInput() {
                let dx = 0, dy = 0;
                
                if (this.keys['ArrowLeft']) dx = -1;
                if (this.keys['ArrowRight']) dx = 1;
                if (this.keys['ArrowUp']) dy = -1;
                if (this.keys['ArrowDown']) dy = 1;
                
                this.player.move(dx, dy, this);
            }
            
            canMoveTo(x, y, size) {
                if (this.currentScreen !== 'town') {
                    // Inside building - can move anywhere except outside walls (but allow access to exit door)
                    return x >= 58 && y >= 58 && 
                           x + size <= SCREEN_WIDTH - 58 && 
                           y + size <= SCREEN_HEIGHT - 50; // Allow closer to bottom for exit door
                }
                
                // Outside - check valid position
                return this.isValidPosition(x, y, size);
            }
            
            isValidPosition(x, y, size) {
                const playerRight = x + size;
                const playerBottom = y + size;
                
                // Check game area bounds (not sidebar)
                if (x < GAME_OFFSET_X || y < 0 || playerRight > SCREEN_WIDTH || playerBottom > SCREEN_HEIGHT) {
                    return false;
                }
                
                // Check building collisions
                for (const building of this.buildings) {
                    if (x < building.x + building.width &&
                        playerRight > building.x &&
                        y < building.y + building.height &&
                        playerBottom > building.y) {
                        return false;
                    }
                }
                
                // Check if player is on roads or driveways (not grass)
                return this.isOnRoadOrDriveway(x, y, size);
            }
            
            isOnRoadOrDriveway(x, y, size) {
                const playerRight = x + size;
                const playerBottom = y + size;
                
                // Road dimensions
                const roadHeight = CELL_HEIGHT * 0.75;
                const roadVerticalOffset = CELL_HEIGHT * 0.125;
                const roadWidth = CELL_WIDTH * 0.75;
                const roadHorizontalOffset = CELL_WIDTH * 0.125;
                
                // Check horizontal roads (rows 1, 4, 7)
                const roadRows = [1, 4, 7];
                for (const row of roadRows) {
                    const roadPos = gridToScreen(1, row);
                    const roadY = roadPos.y + roadVerticalOffset;
                    
                    if (y >= roadY && playerBottom <= roadY + roadHeight) {
                        return true;
                    }
                }
                
                // Check vertical roads (columns 4, 8, 11)
                const roadCols = [4, 8, 11];
                for (const col of roadCols) {
                    const roadPos = gridToScreen(col, 1);
                    const roadX = roadPos.x + roadHorizontalOffset;
                    
                    if (x >= roadX && playerRight <= roadX + roadWidth) {
                        return true;
                    }
                }
                
                // Check driveways
                for (const building of this.buildings) {
                    if (x >= building.drivewayX && 
                        playerRight <= building.drivewayX + building.drivewayWidth &&
                        y >= building.drivewayY && 
                        playerBottom <= building.drivewayY + building.drivewayHeight+50) {
                        return true;
                    }
                }
                
                return false; // Cannot move on grass
            }
            
            drawTown() {
                // Draw sidebar background
                ctx.fillStyle = '#2c3e50';
                ctx.fillRect(0, 0, SIDEBAR_WIDTH, SCREEN_HEIGHT);
                
                // Draw sidebar border
                ctx.strokeStyle = '#34495e';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(SIDEBAR_WIDTH, 0);
                ctx.lineTo(SIDEBAR_WIDTH, SCREEN_HEIGHT);
                ctx.stroke();
                
                // Draw grass background for game area
                ctx.fillStyle = COLORS.GRASS;
                ctx.fillRect(GAME_OFFSET_X, 0, GAME_WIDTH, SCREEN_HEIGHT);
                
                // Draw horizontal roads on rows 1, 4, and 7 (75% of cell height)
                ctx.fillStyle = COLORS.ROAD;
                
                const roadRows = [1, 4, 7];
                const roadHeight = CELL_HEIGHT * 0.75;
                const roadVerticalOffset = CELL_HEIGHT * 0.125; // Center the road in the cell
                
                for (const row of roadRows) {
                    const roadPos = gridToScreen(1, row);
                    ctx.fillRect(GAME_OFFSET_X, roadPos.y + roadVerticalOffset, GAME_WIDTH, roadHeight);
                }
                
                // Draw vertical roads on columns 4, 8, and 11 (75% of cell width)
                const roadCols = [4, 8, 11];
                const roadWidth = CELL_WIDTH * 0.75;
                const roadHorizontalOffset = CELL_WIDTH * 0.125; // Center the road in the cell
                
                for (const col of roadCols) {
                    const roadPos = gridToScreen(col, 1);
                    ctx.fillRect(roadPos.x + roadHorizontalOffset, 0, roadWidth, SCREEN_HEIGHT);
                }
                
                // Draw road markings
                ctx.fillStyle = COLORS.WHITE;
                
                // Horizontal road markings
                for (const row of roadRows) {
                    const roadPos = gridToScreen(1, row);
                    const roadCenterY = roadPos.y + roadVerticalOffset + roadHeight / 2;
                    
                    for (let i = GAME_OFFSET_X; i < SCREEN_WIDTH; i += 60) {
                        ctx.fillRect(i, roadCenterY - 2, 30, 4);
                    }
                }
                
                // Vertical road markings
                for (const col of roadCols) {
                    const roadPos = gridToScreen(col, 1);
                    const roadCenterX = roadPos.x + roadHorizontalOffset + roadWidth / 2;
                    
                    for (let i = 0; i < SCREEN_HEIGHT; i += 60) {
                        ctx.fillRect(roadCenterX - 2, i, 4, 30);
                    }
                }
                
                // Draw buildings
                for (const building of this.buildings) {
                    building.draw();
                }
                
                // Draw player
                this.player.draw();
                
                // Draw inventory UI
                this.drawInventory();
            }
            
            checkBuildingEntry() {
                for (const building of this.buildings) {
                    if (building.checkDoorCollision(this.player)) {
                        this.enterBuilding(building);
                        return;
                    }
                }
            }
            
            enterBuilding(building) {
                this.currentScreen = 'building';
                this.currentBuilding = building;
                // Position player inside building
                this.player.x = SCREEN_WIDTH / 2 - this.player.size / 2;
                this.player.y = SCREEN_HEIGHT - 100;
            }
            
            exitBuilding() {
                if (this.currentBuilding) {
                    this.currentScreen = 'town';
                    // Position player on the building's driveway
                    this.player.x = this.currentBuilding.drivewayX + (this.currentBuilding.drivewayWidth - this.player.size) / 2;
                    this.player.y = this.currentBuilding.drivewayY + 10;
                    this.currentBuilding = null;
                }
            }
            
            checkBuildingExit() {
                if (this.currentBuilding && this.currentBuilding.checkInteriorExit(this.player)) {
                    this.exitBuilding();
                }
            }
            
            checkPuzzlePieceCollection() {
                if (this.currentBuilding && this.currentBuilding.checkPuzzlePieceCollection(this.player, this)) {
                    if (!this.collectedFromBuildings.has(this.currentBuilding.name)) {
                        this.collectedFromBuildings.add(this.currentBuilding.name);
                        this.collectedPieces++;
                    }
                }
            }
            
            drawInventory() {
                // Sidebar title
                ctx.fillStyle = COLORS.WHITE;
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Unicorn Puzzle', SIDEBAR_WIDTH / 2, 30);
                
                // Collection count
                ctx.font = 'bold 16px Arial';
                ctx.fillText(`${this.collectedPieces} of ${this.totalPuzzlePieces} pieces`, SIDEBAR_WIDTH / 2, 50);
                
                // Live puzzle assembly area
                const puzzleStartY = 70;
                const puzzleWidth = SIDEBAR_WIDTH - 20;
                const puzzleHeight = puzzleWidth * 0.75; // 4:3 aspect ratio
                const puzzleX = 10;
                
                // Puzzle background
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.fillRect(puzzleX, puzzleStartY, puzzleWidth, puzzleHeight);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.strokeRect(puzzleX, puzzleStartY, puzzleWidth, puzzleHeight);
                
                // Draw collected puzzle pieces in their correct positions
                if (this.imageLoaded) {
                    const pieceWidth = puzzleWidth / 4;
                    const pieceHeight = puzzleHeight / 2;
                    
                    // Draw grid lines
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.lineWidth = 1;
                    
                    // Vertical grid lines
                    for (let i = 1; i < 4; i++) {
                        const x = puzzleX + (i * pieceWidth);
                        ctx.beginPath();
                        ctx.moveTo(x, puzzleStartY);
                        ctx.lineTo(x, puzzleStartY + puzzleHeight);
                        ctx.stroke();
                    }
                    
                    // Horizontal grid line
                    const y = puzzleStartY + puzzleHeight / 2;
                    ctx.beginPath();
                    ctx.moveTo(puzzleX, y);
                    ctx.lineTo(puzzleX + puzzleWidth, y);
                    ctx.stroke();
                    
                    // Draw collected pieces
                    for (const [buildingName, pieceNumber] of Object.entries(this.buildingToPiece)) {
                        if (this.collectedFromBuildings.has(buildingName)) {
                            const col = pieceNumber % 4;
                            const row = Math.floor(pieceNumber / 4);
                            
                            const destX = puzzleX + (col * pieceWidth);
                            const destY = puzzleStartY + (row * pieceHeight);
                            
                            // Calculate source coordinates
                            const sourceWidth = this.unicornImage.width / 4;
                            const sourceHeight = this.unicornImage.height / 2;
                            const sourceX = col * sourceWidth;
                            const sourceY = row * sourceHeight;
                            
                            // Draw the piece
                            ctx.drawImage(
                                this.unicornImage,
                                sourceX, sourceY, sourceWidth, sourceHeight,
                                destX + 1, destY + 1, pieceWidth - 2, pieceHeight - 2
                            );
                            
                            // Add piece border
                            ctx.strokeStyle = '#4CAF50';
                            ctx.lineWidth = 2;
                            ctx.strokeRect(destX + 1, destY + 1, pieceWidth - 2, pieceHeight - 2);
                        }
                    }
                    
                    // Draw empty piece outlines for uncollected pieces
                    for (let pieceNumber = 0; pieceNumber < 8; pieceNumber++) {
                        const collected = Object.entries(this.buildingToPiece).some(([buildingName, pNum]) => 
                            pNum === pieceNumber && this.collectedFromBuildings.has(buildingName)
                        );
                        
                        if (!collected) {
                            const col = pieceNumber % 4;
                            const row = Math.floor(pieceNumber / 4);
                            
                            const destX = puzzleX + (col * pieceWidth);
                            const destY = puzzleStartY + (row * pieceHeight);
                            
                            // Draw empty piece outline
                            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                            ctx.lineWidth = 1;
                            ctx.setLineDash([5, 5]);
                            ctx.strokeRect(destX + 1, destY + 1, pieceWidth - 2, pieceHeight - 2);
                            ctx.setLineDash([]);
                            
                            // Piece number
                            ctx.font = '12px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                            ctx.fillText(`${pieceNumber + 1}`, destX + pieceWidth/2, destY + pieceHeight/2 + 3);
                        }
                    }
                } else {
                    // Fallback if image not loaded
                    ctx.font = '24px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.fillText('ü¶Ñ', SIDEBAR_WIDTH / 2, puzzleStartY + puzzleHeight/2);
                    ctx.font = '12px Arial';
                    ctx.fillText('Loading...', SIDEBAR_WIDTH / 2, puzzleStartY + puzzleHeight/2 + 30);
                }
                
                // Progress bar at bottom
                const progressY = puzzleStartY + puzzleHeight + 20;
                const progressWidth = SIDEBAR_WIDTH - 40;
                const progressHeight = 8;
                const progressX = 20;
                
                // Progress background
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.fillRect(progressX, progressY, progressWidth, progressHeight);
                
                // Progress fill
                const progressPercent = this.collectedPieces / this.totalPuzzlePieces;
                ctx.fillStyle = '#4CAF50';
                ctx.fillRect(progressX, progressY, progressWidth * progressPercent, progressHeight);
                
                // Progress border
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 1;
                ctx.strokeRect(progressX, progressY, progressWidth, progressHeight);
                
                // Instructions
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = '#BBB';
                ctx.fillText('Collect pieces from buildings', SIDEBAR_WIDTH / 2, progressY + 25);
            }
            
            update() {
                this.handleInput();
                
                if (this.currentScreen === 'town') {
                    this.checkBuildingEntry();
                } else {
                    this.checkBuildingExit();
                    this.checkPuzzlePieceCollection();
                    
                    // Check if all puzzle pieces collected
                    if (this.collectedPieces >= this.totalPuzzlePieces) {
                        this.currentScreen = 'puzzle';
                    }
                }
            }
            
            draw() {
                ctx.clearRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
                
                if (this.currentScreen === 'town') {
                    this.drawTown();
                } else if (this.currentScreen === 'puzzle') {
                    this.drawPuzzleScreen();
                } else if (this.currentBuilding) {
                    this.currentBuilding.drawInterior(this);
                    this.player.draw();
                }
            }
            
            drawPuzzleScreen() {
                // Clear screen with puzzle background
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
                
                // Title
                ctx.fillStyle = COLORS.WHITE;
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('üéâ Puzzle Complete! üéâ', SCREEN_WIDTH / 2, 150);
                
                // Congratulations message
                ctx.font = '24px Arial';
                ctx.fillText('You collected all the puzzle pieces!', SCREEN_WIDTH / 2, 200);
                
                // Show completed unicorn puzzle
                const puzzleWidth = 320;
                const puzzleHeight = 240;
                const puzzleX = SCREEN_WIDTH / 2 - puzzleWidth / 2;
                const puzzleY = 230;
                
                if (this.imageLoaded) {
                    // Draw the complete unicorn image
                    ctx.drawImage(this.unicornImage, puzzleX, puzzleY, puzzleWidth, puzzleHeight);
                    
                    // Draw grid lines to show puzzle pieces
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 3;
                    
                    // Vertical lines
                    for (let i = 1; i < 4; i++) {
                        const x = puzzleX + (i * puzzleWidth / 4);
                        ctx.beginPath();
                        ctx.moveTo(x, puzzleY);
                        ctx.lineTo(x, puzzleY + puzzleHeight);
                        ctx.stroke();
                    }
                    
                    // Horizontal line
                    const y = puzzleY + puzzleHeight / 2;
                    ctx.beginPath();
                    ctx.moveTo(puzzleX, y);
                    ctx.lineTo(puzzleX + puzzleWidth, y);
                    ctx.stroke();
                    
                    // Outer border
                    ctx.strokeStyle = COLORS.BLACK;
                    ctx.lineWidth = 4;
                    ctx.strokeRect(puzzleX, puzzleY, puzzleWidth, puzzleHeight);
                } else {
                    // Fallback if image didn't load
                    ctx.fillStyle = '#FFF8DC';
                    ctx.fillRect(puzzleX, puzzleY, puzzleWidth, puzzleHeight);
                    ctx.strokeStyle = COLORS.BLACK;
                    ctx.lineWidth = 3;
                    ctx.strokeRect(puzzleX, puzzleY, puzzleWidth, puzzleHeight);
                    
                    ctx.font = '80px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillStyle = COLORS.BLACK;
                    ctx.fillText('ü¶Ñ', SCREEN_WIDTH / 2, puzzleY + puzzleHeight/2 + 25);
                }
                
                // Play Again Button
                this.restartButtonX = SCREEN_WIDTH / 2 - 100;
                this.restartButtonY = 520;
                this.restartButtonWidth = 200;
                this.restartButtonHeight = 50;
                
                // Button background
                ctx.fillStyle = '#4CAF50';
                ctx.fillRect(this.restartButtonX, this.restartButtonY, this.restartButtonWidth, this.restartButtonHeight);
                ctx.strokeStyle = COLORS.WHITE;
                ctx.lineWidth = 3;
                ctx.strokeRect(this.restartButtonX, this.restartButtonY, this.restartButtonWidth, this.restartButtonHeight);
                
                // Button text
                ctx.fillStyle = COLORS.WHITE;
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('üîÑ Play Again', SCREEN_WIDTH / 2, this.restartButtonY + 32);
                
                // Thank you message
                ctx.fillStyle = '#BBB';
                ctx.font = '18px Arial';
                ctx.fillText('Thank you for playing Town Explorer!', SCREEN_WIDTH / 2, 600);
            }
            
            gameLoop() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // Start the game
        const game = new Game();
        game.gameLoop();
    </script>
</body>
</html>